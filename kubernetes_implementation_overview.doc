Kubernetes Implementation Overview

A pod is the smallest deployable unit in Kubernetes. It represents one or more containers that share the same network IP, 
storage, and configuration. All containers in a pod run on the same node and can easily communicate with each other. 
Pods are used to run your application workloads in Kubernetes.

Service Account

A service account in Kubernetes is an identity used by pods to interact with the Kubernetes API. It provides credentials for processes 
running inside pods, allowing them to access resources, perform actions, or authenticate to other services. Service accounts are commonly 
used for automation, controllers, and applications that need API access.

The default service account in Kubernetes is automatically created in every namespace. When you deploy a pod and do not specify a service 
account, Kubernetes assigns the pod to the default service account of its namespace.

A namespace  in k8s is a way to divide cluster resources between multiple users (via resource quota).

It provides basic credentials for the pod to interact with the Kubernetes API.
By default, it has limited permissions (usually read-only access).
You can see it with: kubectl get serviceaccount
For most workloads, you should create custom service accounts with specific permissions for security.
In summary:
The default service account is a basic identity for pods, used when no other service account is specified.

A pod need a specific service account when:

It requires specific permissions to access Kubernetes resources.
It needs to authenticate with external services or APIs.
It runs automation tasks that require API access.
It needs to interact with other Kubernetes components securely.

We can create a role with required permissions and bind it with service account using role binding or clustor role binding.

Deployment

We need two types of Resources to deploy a project in Kubernetes.

1. Deployment - Responsible for Scaling and Healing,
2. Service - Responsible for service discovery

Deployment Resource

Scaling - Ensures that the desired number of pod replicas are running and can automatically adjust the number of replicas based on demand.

Healing - Automatically replaces or restarts failed or unhealthy pods to maintain the desired state of the application.

When we want to deploy a micro service, we typically create a Deployment resource to manage the pods running the micro service. 
It will create a intermediate resource called ReplicaSet. This will spinup containers or pods. 

In deployment YAML file, we define the desired state of the application, including the container image, replicas, and other configurations. 
Kubernetes will ensure that the actual state matches the desired state. 

If one replica fails, the Deployment controller will automatically create a new pod to replace it, ensuring that the desired number of replicas is always 
maintained and it is called as self-healing.

A "replica" is an instance of a pod, but the pod itself is the resource definition. Replicas are used to run multiple identical pods for redundancy and load balancing


Service Resource

The main problem with pods is that they are ephemeral, meaning they can be created and destroyed frequently. This makes it difficult to reliably 
access them using their IP addresses. This is called as service discovery problem.

To solve this problem, Kubernetes provides a stable endpoint for accessing pods through a Service resource. A Service is an abstraction that defines a 
logical set of pods and a policy by which to access them.

Services enable communication between different parts of an application, as well as between applications. They provide load balancing, service discovery, 
and stable network identities for pods.

Service is a proxy that sits in front of a set of pods and routes traffic to them. It abstracts away the underlying pod IPs and provides a single stable 
endpoint for clients to access the pods. This allows clients to communicate with the service without needing to know the details of the individual pods.

Service is not only for internal communication but can also be exposed externally to allow access from outside the cluster.

Deploy Project in to kubernetes.

navigate to the directory where deployment located.

in serviceaccount.yaml define the service account.

apiVersion: v1
kind: ServiceAccount
metadata:
  name: opentelemetry-demo
  labels:

    opentelemetry.io/name: opentelemetry-demo
    app.kubernetes.io/instance: opentelemetry-demo
    app.kubernetes.io/name: opentelemetry-demo
    app.kubernetes.io/version: "1.12.0"
    app.kubernetes.io/part-of: opentelemetry-demo


then

kubectl apply -f serviceaccount.yaml

to create the required service account.

kubectl get sa

NAME                 SECRETS   AGE
default              0         93m  <------ default service account
opentelemetry-demo   0         45s  <------ custom service account


kubectl apply -f deployment.yaml

after creating the service account we can run the deployment file.


Detailed breakdown of a typical Kubernetes deployment manifest like deploy.yaml:

apiVersion: Specifies the Kubernetes API version (e.g., apps/v1).

In Kubernetes, the "apiVersion" field in a manifest file specifies which version of the Kubernetes API should be used to 
process and manage the resource described in the file.

Each resource type (like Deployment, Service, Pod) may have different API versions, such as:

v1 (for core resources like Pod, Service)
apps/v1 (for resources like Deployment, StatefulSet)
batch/v1 (for resources like Job, CronJob)
The apiVersion ensures compatibility and determines which features and schema are available for that 
resource. Using the correct apiVersion is important for Kubernetes to understand and correctly 
handle the resource.

kind: Indicates the resource type, usually Deployment.

In Kubernetes manifests, the "kind" field specifies the type of resource you want to create or manage.

Examples of "kind" values include:

Pod: A single container or group of containers.
Service: Exposes a set of pods as a network service.
Deployment: Manages a set of replicated pods, enabling updates and scaling.
ConfigMap, Secret, StatefulSet, etc.

The "kind" tells Kubernetes what action to take and how to interpret the rest of the manifest. 
Each kind has its own structure and purpose within the cluster.

metadata: Contains identifying information such as name, namespace, and labels for the deployment.

Labels in Kubernetes metadata are used to organize, identify, and select resources. 
They are key-value pairs attached to objects like pods, deployments, and services.

Reasons for using labels:

Enable grouping and filtering of resources (e.g., select all pods with app=accounting).
Facilitate service discovery and load balancing.
Support deployment strategies, scaling, and rolling updates.
Help manage environments (e.g., env=prod, env=dev).
Labels make it easy to manage and automate operations in large clusters by 
allowing flexible queries and resource selection.

A namespace in Kubernetes is used to divide cluster resources between multiple users, teams, or environments. It provides a way 
to organize and isolate resources such as pods, services, and deployments.

Reasons for using namespaces:

Separation of environments (e.g., development, testing, production).
Resource isolation for security and management.
Avoiding naming conflicts between resources.
Delegating access and permissions to different teams.
Namespaces help manage large clusters by grouping related resources and controlling access.

spec:

replicas: Number of pod instances to run for the service.
selector: Defines how Kubernetes matches pods to this deployment using labels.
template:
metadata: Labels for the pods created by this deployment.
spec:
containers: List of containers to run in each pod.
name: Name of the container.
image: Docker image for the accounting service.
ports: Exposed container ports.
env: Environment variables for configuration.
resources: CPU and memory limits/requests.
livenessProbe/readinessProbe: Health checks to ensure the pod is running and ready.

Service File

A Service file in Kubernetes is a YAML manifest that defines a network service to expose a set of pods. 
It provides a stable endpoint for accessing pods, load balancing traffic, and service discovery.

Main components:

apiVersion: Specifies the API version (usually v1).
kind: Indicates the resource type (Service).
metadata: Contains the name and labels for identification.

spec:
type: How the service is exposed (ClusterIP, NodePort, LoadBalancer).
ports: Defines which ports the service exposes and maps them to pod ports.
selector: Uses labels to select the pods that receive traffic.

ClusterIP:
The default type. Makes the service accessible only within the Kubernetes cluster. 
Used for internal communication between services and pods.

NodePort:
Exposes the service on a static port on each nodeâ€™s IP address. 
Allows external access to the service using <NodeIP>:<NodePort>. Useful for development or simple external access.

LoadBalancer:
Provisions an external load balancer (if supported by the cloud provider). 
Exposes the service to the internet, distributing traffic across nodes and pods. Used for production-grade, public-facing services.


Purpose:
Ensures reliable communication between components.
Provides load balancing and a single access point for pods.
Enables service discovery within the cluster.



